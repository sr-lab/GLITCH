# type: ignore
# Built upon the work done by Nuno Saveedra and João Gonçalves
import os

from hcl2.parser import hcl2
import glitch.parsers.parser as p

from glitch.exceptions import EXCEPTIONS, throw_exception
from glitch.repr.inter import *
from typing import List, Dict, Any

from lark.tree import Meta, Tree
from lark.lexer import Token
from lark.visitors import Transformer, v_args, Discard


class GLITCHTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a dict.
    """

    def __init__(self, code: List[str]):
        self.code = code
        self.comments = []
        super().__init__()

    def new_line_or_comment(self, args: List) -> List:
        for arg in args:
            if isinstance(arg, Token):
                if arg.value.startswith(("//", "#", "/*")):
                    comment = Comment(arg.value)
                    comment.line, comment.column = arg.line, arg.column
                    comment.end_line, comment.end_column = arg.end_line, arg.end_column
                    self.comments.append(comment)
        return Discard

    def new_line_and_or_comma(self, args: List) -> List:
        return Discard

    def __get_element_code(
        self, start_line: int, start_col: int, end_line: int, end_col: int
    ) -> str:
        if start_line == end_line:
            res = self.code[start_line - 1][max(0, start_col - 1) : end_col - 1]
        else:
            res = self.code[start_line - 1][max(0, start_col - 1) :]

        for line in range(start_line, end_line - 1):
            res += self.code[line]

        if start_line != end_line:
            res += self.code[end_line - 1][: end_col - 1]

        return res

    def __get_element_info(self, meta: Meta | Token) -> ElementInfo:
        return ElementInfo(
            meta.line,
            meta.column,
            meta.end_line,
            meta.end_column,
            self.__get_element_code(
                meta.line,
                meta.column,
                meta.end_line,
                meta.end_column,
            ),
        )

    def __get_element_info_from_tokens(self, start: Token, end: Token) -> ElementInfo:
        return ElementInfo(
            start.line,
            start.column,
            end.end_line,
            end.end_column,
            self.__get_element_code(
                start.line,
                start.column,
                end.end_line,
                end.end_column,
            ),
        )

    def __parse_heredoc(self, tree: Tree) -> str:
        res = ""
        for arg in tree.children:
            res += arg.value
        return "\n".join(res.split("\n")[1:-1])

    @v_args(meta=True)
    def binary_op(self, meta: Meta, args: List) -> Any:
        op_to_ir = {
            "+": Sum,
            "-": Subtract,
            "*": Multiply,
            "/": Divide,
            "%": Modulo,
            "&&": And,
            "||": Or,
            "==": Equal,
            "!=": NotEqual,
            ">": GreaterThan,
            "<": LessThan,
            ">=": GreaterThanOrEqual,
            "<=": LessThanOrEqual,
        }

        if args[1].children[0].children[0] in op_to_ir:
            return op_to_ir[args[1].children[0].children[0]](
                self.__get_element_info_from_tokens(args[0], args[1].children[1]),
                args[0],
                args[1].children[1],
            )

    @v_args(meta=True)
    def unary_op(self, meta: Meta, args: List) -> Any:
        if args[0] == "-":
            return Minus(self.__get_element_info(meta), args[1])
        elif args[0] == "!":
            return Not(self.__get_element_info(meta), args[1])

    @v_args(meta=True)
    def get_attr(self, meta: Meta, args: List) -> Any:
        return args[0]

    @v_args(meta=True)
    def index(self, meta: Meta, args: List) -> Any:
        return args[0]

    @v_args(meta=True)
    def index_expr_term(self, meta: Meta, args: List) -> Any:
        return Access(self.__get_element_info(meta), args[0], args[1])

    @v_args(meta=True)
    def get_attr_expr_term(self, meta: Meta, args: List) -> Any:
        return Access(self.__get_element_info(meta), args[0], args[1])

    @v_args(meta=True)
    def int_lit(self, meta: Meta, args: List) -> int:
        return Integer(int("".join(args)), self.__get_element_info(meta))

    @v_args(meta=True)
    def float_lit(self, meta: Meta, args: List) -> float:
        return Float(float("".join(args)), self.__get_element_info(meta))

    @v_args(meta=True)
    def interpolation_maybe_nested(self, meta: Meta, args: List) -> Any:
        return args[0]

    @v_args(meta=True)
    def string_with_interpolation(self, meta: Meta, args: List) -> str:
        if len(args) == 1:
            if isinstance(args[0], Token):
                return String(
                    args[0].value,
                    self.__get_element_info(meta),
                )
            return args[0]
        else:
            for i in range(len(args)):
                if isinstance(args[i], Token):
                    args[i] = String(
                        args[i].value,
                        self.__get_element_info(args[i]),
                    )

            res = Sum(
                ElementInfo(
                    args[0].line,
                    args[0].column,
                    args[1].end_line,
                    args[1].end_column,
                    self.__get_element_code(
                        args[0].line,
                        args[0].column,
                        args[1].end_line,
                        args[1].end_column,
                    ),
                ),
                args[0],
                args[1],
            )
            for i in range(2, len(args)):
                res = Sum(
                    ElementInfo(
                        res.line,
                        res.column,
                        args[i].end_line,
                        args[i].end_column,
                        self.__get_element_code(
                            res.line,
                            res.column,
                            args[i].end_line,
                            args[i].end_column,
                        ),
                    ),
                    res,
                    args[i],
                )
            res.line, res.column = meta.line, meta.column
            res.end_line, res.end_column = meta.end_line, meta.end_column

            return res

    @v_args(meta=True)
    def expr_term(self, meta: Meta, args: List) -> Expr:
        if len(args) == 0:
            return Null(self.__get_element_info(meta))
        elif len(args) == 1:
            if isinstance(args[0], Tree) and args[0].data == "heredoc_template":
                return String(
                    self.__parse_heredoc(args[0]),
                    self.__get_element_info(meta),
                )
            if isinstance(args[0], Expr):
                return args[0]
            if args[0].type == "STRING_LIT":
                return String(
                    args[0].value[1:-1],
                    self.__get_element_info(args[0]),
                )
            return args[0]
        return args

    def object_elem(self, args: List) -> Expr:
        if len(args) == 2:
            return (args[0], args[1])
        else:
            return (args[0], args[2])

    @v_args(meta=True)
    def object(self, meta: Meta, args: List) -> Any:
        object_elems = {}
        for k, v in args:
            object_elems[k] = v
        res = Hash(object_elems, self.__get_element_info(meta))
        return res

    @v_args(meta=True)
    def tuple(self, meta: Meta, args: List) -> Any:
        return Array(args, self.__get_element_info(meta))

    @v_args(meta=True)
    def block(self, meta: Meta, args: List) -> Any:

        if args[0].value == "task":
            def get_task_type(atts:List[Any]) -> str:
                for elem in atts:
                    if isinstance(elem,(Attribute,UnitBlock)):
                        if elem.name == "driver":
                            return elem.value.value
            
            name:String = String(args[1].value,self.__get_element_info(args[1]))
            au = AtomicUnit(name,f"task.{get_task_type(args[-1])}")
            for elem in args[-1]:
                if isinstance(elem,Attribute):
                    au.add_attribute(elem)
                else:
                    print(f"#####ERROR PARSING ELEMENT:{elem} IN A TASK#####")
            return au

        elif args[0].value == "group":
            ub:UnitBlock = UnitBlock(args[1].value,UnitBlockType.block)

            for elem in args[-1]:
                if isinstance(elem,AtomicUnit):
                    ub.add_atomic_unit(elem)
                elif isinstance(elem,Attribute):
                    ub.add_attribute(elem)
                else:
                    print(f"#####ERROR PARSING ELEMENT:{elem} IN A GROUP#####")
            return ub
            
        elif args[0].value not in ["job","group","task","port"]:
            
            subatts: Dict[String, Expr] = {}

            for elem in args[-1]:
                if isinstance(elem, Attribute):
                    if isinstance(elem.value, VariableReference):
                        #  Attribute(VariableReference())
                        #  Review this decision, I might be throwing away important info/expressivity of the IR by doing VariableReference -> String
                        subatts[
                            String(elem.name, ElementInfo.from_code_element(elem))
                        ] = String(
                            elem.value.value, ElementInfo.from_code_element(elem.value)
                        )
                    else:
                        if isinstance(elem.name, VariableReference):
                            subatts[elem.name] = elem.value
                        else:
                            subatts[
                                String(elem.name, ElementInfo.from_code_element(elem))
                            ] = elem.value
                else:
                    print(f"#####ERROR PARSING ELEMENT:{elem} IN A BLOCK#####")

            info: ElementInfo = self.__get_element_info(meta)
            val_hash: Hash = Hash(subatts, info)

            return Attribute(args[0].value, val_hash, info)
        
        elif args[0].value == "port":
            # port block inside network block inside resource blocks | args[1] is the string literal that has the port name
            atts: Dict[String, Expr] = {}

            for elem in args[-1]:
                atts[String(elem.name, ElementInfo.from_code_element(elem))] = (
                    elem.value
                )

            val_hash: Hash = Hash(
                {
                    String("port_name", self.__get_element_info(args[1])): String(
                        args[1].value, self.__get_element_info(args[1])
                    ),
                    **atts,
                },
                self.__get_element_info(meta),
            )

            return Attribute(args[0], val_hash, self.__get_element_info(meta))

        else:
            #job
            ub = UnitBlock(args[0].value, UnitBlockType.script)
            for arg in args[-1]:
                if isinstance(arg, AtomicUnit):
                    ub.add_atomic_unit(arg)
                elif isinstance(arg, UnitBlock):
                    ub.add_unit_block(arg)
                elif isinstance(arg, Attribute):
                    ub.add_attribute(arg)

            ub.set_element_info(self.__get_element_info(meta))
            return ub

    def body(self, args: List) -> Any:
        return args

    @v_args(meta=True)
    def conditional(self, meta: Meta, args: List) -> Any:
        condition = ConditionalStatement(
            args[0],
            ConditionalStatement.ConditionType.IF,
        )
        condition.line, condition.column = meta.line, meta.column
        condition.end_line, condition.end_column = meta.end_line, meta.end_column
        condition.add_statement(args[1])
        condition.else_statement = ConditionalStatement(
            Null(),
            ConditionalStatement.ConditionType.IF,
        )
        condition.else_statement.add_statement(args[2])
        return condition

    @v_args(meta=True)
    def attribute(self, meta: Meta, args: List) -> Attribute:
        return Attribute(args[0].value, args[2], self.__get_element_info(meta))

    @v_args(meta=True)
    def identifier(self, meta: Meta, value: Any) -> Expr:
        if value[0] == "null":
            return Null(self.__get_element_info(meta))
        elif value[0] in ["true", "false"]:
            return Boolean(value[0] == "true", self.__get_element_info(meta))
        name = value[0]
        if isinstance(name, Token):
            name = name.value
        return VariableReference(name, self.__get_element_info(meta))

    @v_args(meta=True)
    def attr_splat_expr_term(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta))

    @v_args(meta=True)
    def full_splat_expr_term(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta))

    @v_args(meta=True)
    def for_tuple_expr(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta))

    @v_args(meta=True)
    def for_object_expr(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta))

    @v_args(meta=True)
    def function_call(self, meta: Meta, args: List) -> Any:
        if len(args) == 1:
            return FunctionCall(
                args[0],
                [],
                self.__get_element_info(meta),
            )
        return FunctionCall(
            args[0],
            args[1],
            self.__get_element_info(meta),
        )

    def arguments(self, args: List) -> Any:
        return args

    def start(self, args: List):
        return args[0]


class NomadParser(p.Parser):
    def parse_file(self, path: str, type: UnitBlockType) -> UnitBlock:
        
        try:
            with open(path) as f:
                unit_block = None
                tree = hcl2.parse(f.read() + "\n")
                f.seek(0, 0)
                code = f.readlines()
                transformer = GLITCHTransformer(code)
                elements = transformer.transform(tree)

                if elements and isinstance(elements[0], UnitBlock):
                    unit_block = elements[0]
                    unit_block.path = path
                else:
                    throw_exception(EXCEPTIONS["HASHICORP_NOMAD_COULD_NOT_PARSE"], path)
                    return None

                for c in transformer.comments:
                    unit_block.add_comment(c)
        except:
            throw_exception(EXCEPTIONS["HASHICORP_NOMAD_COULD_NOT_PARSE"], path)
            return None
        
        return unit_block

    def parse_module(self, path: str) -> Module:
        res: Module = Module(os.path.basename(os.path.normpath(path)), path)
        super().parse_file_structure(res.folder, path)

        files = [
            f.path for f in os.scandir(f"{path}") if f.is_file() and not f.is_symlink()
        ]
        for f in files:
            unit_block = self.parse_file(f, UnitBlockType.unknown)
            res.add_block(unit_block)

        return res

    def parse_folder(self, path: str) -> Project:
        res: Project = Project(os.path.basename(os.path.normpath(path)))
        res.add_module(self.parse_module(path))

        subfolders = [
            f.path for f in os.scandir(f"{path}") if f.is_dir() and not f.is_symlink()
        ]
        for d in subfolders:
            aux = self.parse_folder(d)
            res.blocks += aux.blocks
            res.modules += aux.modules

        return res








