# type: ignore
import os

from hcl2.parser import hcl2
import glitch.parsers.parser as p
from glitch.parsers.terraform import GLITCHTransformer
from glitch.exceptions import EXCEPTIONS, throw_exception
from glitch.repr.inter import *
from typing import List, Dict, Any

from lark.tree import Meta
from lark.visitors import v_args


class NomadTransformer(GLITCHTransformer):
    """Takes a syntax tree generated by the parser and
    transforms it into a dict.
    """

    def __init__(self, code: List[str]):
        super().__init__(code)
        self.path = ""

    @v_args(meta=True)
    def block(self, meta: Meta, args: List) -> Any:
        if args[0].value == "task":

            def get_task_type(atts: List[Any]) -> str:
                for elem in atts:
                    if isinstance(elem, (Attribute, UnitBlock)):
                        if elem.name == "driver":
                            return elem.value.value

            name: String = String(args[1].value, self._get_element_info(args[1]))
            au = AtomicUnit(name, f"task.{get_task_type(args[-1])}")
            for elem in args[-1]:
                if isinstance(elem, Attribute):
                    au.add_attribute(elem)
                else:
                    print(f"#####ERROR PARSING ELEMENT:{elem} IN A TASK#####")
            return au

        elif args[0].value == "group":
            ub: UnitBlock = UnitBlock(args[1].value, UnitBlockType.block)
            ub.path = self.path
            for elem in args[-1]:
                if isinstance(elem, AtomicUnit):
                    ub.add_atomic_unit(elem)
                elif isinstance(elem, Attribute):
                    ub.add_attribute(elem)
                else:
                    print(f"#####ERROR PARSING ELEMENT:{elem} IN A GROUP#####")
            return ub

        elif args[0].value not in ["job", "group", "task", "port"]:
            subatts: Dict[String, Expr] = {}

            for elem in args[-1]:
                if isinstance(elem, Attribute):
                    if isinstance(elem.value, VariableReference):
                        #  Attribute(VariableReference())
                        #  Review this decision, I might be throwing away important info/expressivity of the IR by doing VariableReference -> String
                        subatts[
                            String(elem.name, ElementInfo.from_code_element(elem))
                        ] = String(
                            elem.value.value, ElementInfo.from_code_element(elem.value)
                        )
                    else:
                        if isinstance(elem.name, VariableReference):
                            subatts[elem.name] = elem.value
                        else:
                            subatts[
                                String(elem.name, ElementInfo.from_code_element(elem))
                            ] = elem.value
                else:
                    print(f"#####ERROR PARSING ELEMENT:{elem} IN A BLOCK#####")

            info: ElementInfo = self._get_element_info(meta)
            val_hash: Hash = Hash(subatts, info)

            return Attribute(args[0].value, val_hash, info)

        elif args[0].value == "port":
            # port block inside network block inside resource blocks | args[1] is the string literal that has the port name
            atts: Dict[String, Expr] = {}

            for elem in args[-1]:
                atts[String(elem.name, ElementInfo.from_code_element(elem))] = (
                    elem.value
                )

            val_hash: Hash = Hash(
                {
                    String("port_name", self._get_element_info(args[1])): String(
                        args[1].value, self._get_element_info(args[1])
                    ),
                    **atts,
                },
                self._get_element_info(meta),
            )

            return Attribute(args[0], val_hash, self._get_element_info(meta))

        else:
            # job
            ub = UnitBlock(args[0].value, UnitBlockType.script)
            for arg in args[-1]:
                if isinstance(arg, AtomicUnit):
                    ub.add_atomic_unit(arg)
                elif isinstance(arg, UnitBlock):
                    ub.add_unit_block(arg)
                elif isinstance(arg, Attribute):
                    ub.add_attribute(arg)

            ub.set_element_info(self._get_element_info(meta))
            return ub


class NomadParser(p.Parser):
    def parse_file(self, path: str, type: UnitBlockType) -> UnitBlock:
        try:
            with open(path) as f:
                unit_block = None
                tree = hcl2.parse(f.read() + "\n")
                f.seek(0, 0)
                code = f.readlines()
                transformer = NomadTransformer(code)
                transformer.path = os.path.abspath(path)
                elements = transformer.transform(tree)

                if elements and isinstance(elements[0], UnitBlock):
                    unit_block = elements[0]
                    unit_block.path = os.path.abspath(path)
                else:
                    throw_exception(EXCEPTIONS["HASHICORP_NOMAD_COULD_NOT_PARSE"], path)
                    return None

                for c in transformer.comments:
                    unit_block.add_comment(c)
        except:
            throw_exception(EXCEPTIONS["HASHICORP_NOMAD_COULD_NOT_PARSE"], path)
            return None

        return unit_block

    def parse_module(self, path: str) -> Module:
        res: Module = Module(os.path.basename(os.path.normpath(path)), path)
        super().parse_file_structure(res.folder, path)

        files = [
            f.path for f in os.scandir(f"{path}") if f.is_file() and not f.is_symlink()
        ]
        for f in files:
            unit_block = self.parse_file(f, UnitBlockType.unknown)
            res.add_block(unit_block)

        return res

    def parse_folder(self, path: str) -> Project:
        res: Project = Project(os.path.basename(os.path.normpath(path)))
        res.add_module(self.parse_module(path))

        subfolders = [
            f.path for f in os.scandir(f"{path}") if f.is_dir() and not f.is_symlink()
        ]
        for d in subfolders:
            aux = self.parse_folder(d)
            res.blocks += aux.blocks
            res.modules += aux.modules

        return res
