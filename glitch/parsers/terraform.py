# type: ignore (#TODO)
import os
from hcl2.parser import hcl2
import glitch.parsers.parser as p

from glitch.exceptions import EXCEPTIONS, throw_exception
from glitch.repr.inter import *
from typing import List, Any

from lark.tree import Meta, Tree
from lark.lexer import Token
from lark.visitors import Transformer, v_args, Discard


class GLITCHTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a dict.
    """

    class ObjectType(Enum):
        RESOURCE = 1
        ATTRIBUTE = 2
        DYNAMIC = 3
        CONTENT = 4

    def __init__(self, code: List[str]):
        self.code = code
        self.attributes = []
        self.comments = []
        self.object_elems = {}
        super().__init__()

    def new_line_or_comment(self, args: List) -> List:
        for arg in args:
            if isinstance(arg, Token):
                if arg.value.startswith(("//", "#", "/*")):
                    comment = Comment(arg.value)
                    comment.line, comment.column = arg.line, arg.column
                    comment.end_line, comment.end_column = arg.end_line, arg.end_column
                    self.comments.append(comment)
        return Discard
    
    def new_line_and_or_comma(self, args: List) -> List:
        return Discard

    def __get_element_code(
        self, start_line: int, start_col: int, end_line: int, end_col: int
    ) -> str:
        if start_line == end_line:
            res = self.code[start_line - 1][max(0, start_col - 1) : end_col - 1]
        else:
            res = self.code[start_line - 1][max(0, start_col - 1) :]

        for line in range(start_line, end_line - 1):
            res += self.code[line]

        if start_line != end_line:
            res += self.code[end_line - 1][: end_col - 1]

        return res

    def __get_element_info(self, meta: Meta | Token) -> ElementInfo:
        return ElementInfo(
            meta.line,
            meta.column,
            meta.end_line,
            meta.end_column,
            self.__get_element_code(
                meta.line,
                meta.column,
                meta.end_line,
                meta.end_column,
            ),
        )
    
    def __get_element_info_from_tokens(self, start: Token, end: Token) -> ElementInfo:
        return ElementInfo(
            start.line,
            start.column,
            end.end_line,
            end.end_column,
            self.__get_element_code(
                start.line,
                start.column,
                end.end_line,
                end.end_column,
            ),
        )
    
    def __parse_heredoc(self, tree: Tree) -> str:
        res = ""
        for arg in tree.children:
            res += arg.value
        return "\n".join(res.split("\n")[1:-1])
    
    @v_args(meta=True)
    def binary_op(self, meta: Meta, args: List) -> Any:
        op_to_ir = {
            "+": Sum,
            "-": Subtract,
            "*": Multiply,
            "/": Divide,
            "%": Modulo,
            "&&": And,
            "||": Or,
            "==": Equal,
            "!=": NotEqual,
            ">": GreaterThan,
            "<": LessThan,
            ">=": GreaterThanOrEqual,
            "<=": LessThanOrEqual,
        }

        if args[1].children[0].children[0] in op_to_ir:
            return op_to_ir[args[1].children[0].children[0]](
                self.__get_element_info_from_tokens(args[0], args[1].children[1]),
                args[0],
                args[1].children[1]
            )
        
    @v_args(meta=True)
    def unary_op(self, meta: Meta, args: List) -> Any:
        if args[0] == "-":
            return Minus(self.__get_element_info(meta), args[1])
        elif args[0] == "!":
            return Not(self.__get_element_info(meta), args[1])

    @v_args(meta=True)
    def get_attr(self, meta: Meta, args: List) -> Any:
        return args[0]
    
    @v_args(meta=True)
    def index(self, meta: Meta, args: List) -> Any:
        return args[0]
    
    @v_args(meta=True)
    def index_expr_term(self, meta: Meta, args: List) -> Any:
        return Access(self.__get_element_info(meta), args[0], args[1])

    @v_args(meta=True)
    def get_attr_expr_term(self, meta: Meta, args: List) -> Any:
        return Access(self.__get_element_info(meta), args[0], args[1])

    @v_args(meta=True)
    def int_lit(self, meta: Meta, args: List) -> int:
        return Integer(int(args[0]), self.__get_element_info(meta))
    
    @v_args(meta=True)
    def float_lit(self, meta: Meta, args: List) -> float:
        return Float(float("".join(args)), self.__get_element_info(meta))
    
    @v_args(meta=True)
    def interpolation_maybe_nested(self, meta: Meta, args: List) -> Any:
        return args[0]
    
    @v_args(meta=True)
    def string_with_interpolation(self, meta: Meta, args: List) -> str:
        if len(args) == 1:
            if isinstance(args[0], Token):
                return String(
                    args[0].value,
                    self.__get_element_info(meta),
                )
            return args[0]
        else:
            for i in range(len(args)):
                if isinstance(args[i], Token):
                    args[i] = String(
                        args[i].value,
                        self.__get_element_info(args[i]),
                    )

            res = Sum(
                ElementInfo(
                    args[0].line,
                    args[0].column,
                    args[1].end_line,
                    args[1].end_column,
                    self.__get_element_code(
                        args[0].line,
                        args[0].column,
                        args[1].end_line,
                        args[1].end_column,
                    )
                ),
                args[0], 
                args[1]
            )
            for i in range(2, len(args), 2):
                res = Sum(
                    ElementInfo(
                        args[i].line,
                        args[i].column,
                        args[i+1].end_line,
                        args[i+1].end_column,
                        self.__get_element_code(
                            args[i].line,
                            args[i].column,
                            args[i+1].end_line,
                            args[i+1].end_column,
                        )
                    ),
                    res, 
                    args[i+1]
                )
            res.line, res.column = meta.line, meta.column
            res.end_line, res.end_column = meta.end_line, meta.end_column

            return res

    @v_args(meta=True)
    def expr_term(self, meta: Meta, args: List) -> Expr:
        if len(args) == 0:
            return Null(self.__get_element_info(meta))
        elif len(args) == 1:
            if isinstance(args[0], Tree) and args[0].data == 'heredoc_template':
                return String(
                    self.__parse_heredoc(args[0]),
                    self.__get_element_info(meta),
                )
            if isinstance(args[0], Expr):
                return args[0]
            if (args[0].type == "STRING_LIT"):
                return String(
                    args[0].value[1:-1],
                    self.__get_element_info(args[0]),
                )
            return args[0]
        return args

    def object_elem(self, args: List) -> Expr:
        self.object_elems[args[0]] = args[2]

    @v_args(meta=True)
    def object(self, meta: Meta, args: List) -> Any:
        res = Hash(self.object_elems, self.__get_element_info(meta))
        self.object_elems = {}
        return res
    
    @v_args(meta=True)
    def tuple(self, meta: Meta, args: List) -> Any:
        return Array(args, self.__get_element_info(meta))

    @v_args(meta=True)
    def block(self, meta: Meta, args: List) -> Any:
        if args[0] == GLITCHTransformer.ObjectType.RESOURCE:
            au = AtomicUnit(
                String(
                    args[2].value[1:-1],  # Remove quotes
                    self.__get_element_info(args[2]),
                ),
                args[1].value[1:-1],
            )
            au.attributes = self.attributes
            au.set_element_info(self.__get_element_info(meta))
            for arg in args[-1]:
                au.add_statement(arg)
            self.attributes = []
            return au
        elif args[0] in [GLITCHTransformer.ObjectType.CONTENT, GLITCHTransformer.ObjectType.DYNAMIC]:
            ub = UnitBlock(str(args[0]), UnitBlockType.block)
            for arg in args[-1]:
                if isinstance(arg, AtomicUnit):
                    ub.add_atomic_unit(arg)
                elif isinstance(arg, UnitBlock):
                    ub.add_unit_block(arg)
            ub.attributes = self.attributes
            ub.set_element_info(self.__get_element_info(meta))
            self.attributes = []
            return ub

    def body(self, args: List) -> Any:
        return args
    
    @v_args(meta=True)
    def conditional(self, meta: Meta, args: List) -> Any:
        condition = ConditionalStatement(
            args[0],
            ConditionalStatement.ConditionType.IF,
        )
        condition.line, condition.column = meta.line, meta.column
        condition.end_line, condition.end_column = meta.end_line, meta.end_column
        condition.add_statement(args[1])
        condition.else_statement = ConditionalStatement(
            Null(),
            ConditionalStatement.ConditionType.IF,
        )
        condition.else_statement.add_statement(args[2])
        return condition

    @v_args(meta=True)
    def attribute(self, meta: Meta, args: List) -> Attribute:
        self.attributes.append(
            Attribute(args[0].value.value, args[2], self.__get_element_info(meta))
        )

    @v_args(meta=True)
    def identifier(self, meta: Meta, value: Any) -> Expr | ObjectType:
        if value[0] == "null":
            return Null(self.__get_element_info(meta))
        elif value[0] in ["true", "false"]:
            return Boolean(value[0] == "true", self.__get_element_info(meta))
        elif value[0] == "resource":
            return GLITCHTransformer.ObjectType.RESOURCE
        elif value[0] == "dynamic":
            return GLITCHTransformer.ObjectType.DYNAMIC
        elif value[0] == "content":
            return GLITCHTransformer.ObjectType.CONTENT
        return VariableReference(value[0], self.__get_element_info(meta))

    @v_args(meta=True)
    def attr_splat_expr_term(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta))
    
    @v_args(meta=True)
    def full_splat_expr_term(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta))
    
    @v_args(meta=True)
    def for_tuple_expr(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta)) 
    
    @v_args(meta=True)
    def for_object_expr(self, meta: Meta, args: List) -> Any:
        # TODO: Not supported yet
        return Null(self.__get_element_info(meta)) 
    
    @v_args(meta=True)
    def function_call(self, meta: Meta, args: List) -> Any:
        return FunctionCall(
            args[0],
            args[1],
            self.__get_element_info(meta),
        )

    def arguments(self, args: List) -> Any:
        return args

    def start(self, args: List):
        return args[0]


class TerraformParser(p.Parser):
    def parse_file(self, path: str, type: UnitBlockType) -> UnitBlock:
        unit_block = UnitBlock(path, type)
        unit_block.path = path
        try:
            with open(path) as f:
                tree = hcl2.parse(f.read() + "\n")
                f.seek(0, 0)
                code = f.readlines()
                transformer = GLITCHTransformer(code)
                elements = transformer.transform(tree)
                for el in elements:
                    if isinstance(el, AtomicUnit):
                        unit_block.add_atomic_unit(el)
                for c in transformer.comments:
                    unit_block.add_comment(c)
        except:
            throw_exception(EXCEPTIONS["TERRAFORM_COULD_NOT_PARSE"], path)
        return unit_block

    def parse_module(self, path: str) -> Module:
        res: Module = Module(os.path.basename(os.path.normpath(path)), path)
        super().parse_file_structure(res.folder, path)

        files = [
            f.path for f in os.scandir(f"{path}") if f.is_file() and not f.is_symlink()
        ]
        for f in files:
            unit_block = self.parse_file(f, UnitBlockType.unknown)
            res.add_block(unit_block)

        return res

    def parse_folder(self, path: str) -> Project:
        res: Project = Project(os.path.basename(os.path.normpath(path)))
        res.add_module(self.parse_module(path))

        subfolders = [
            f.path for f in os.scandir(f"{path}") if f.is_dir() and not f.is_symlink()
        ]
        for d in subfolders:
            aux = self.parse_folder(d)
            res.blocks += aux.blocks
            res.modules += aux.modules

        return res
