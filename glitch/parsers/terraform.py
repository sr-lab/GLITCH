# type: ignore (#TODO)
import os
from hcl2.parser import hcl2
import glitch.parsers.parser as p

from glitch.exceptions import EXCEPTIONS, throw_exception
from glitch.repr.inter import *
from typing import Sequence, List, Dict, Any

from lark.tree import Meta, Tree
from lark.lexer import Token
from lark.visitors import Transformer, v_args, Discard


class GLITCHTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a dict.
    """

    class ObjectType(Enum):
        RESOURCE = 1
        ATTRIBUTE = 2
        DYNAMIC = 3

    def __init__(self, code: List[str]):
        self.code = code
        self.attributes = []
        self.comments = []
        self.object_elems = {}
        super().__init__()

    def new_line_or_comment(self, args: List) -> List:
        for arg in args:
            if isinstance(arg, Token):
                if arg.value.startswith(("//", "#", "/*")):
                    comment = Comment(arg.value)
                    comment.line, comment.column = arg.line, arg.column
                    comment.end_line, comment.end_column = arg.end_line, arg.end_column
                    self.comments.append(comment)
        return Discard
    
    def new_line_and_or_comma(self, args: List) -> List:
        return Discard

    def __get_element_code(
        self, start_line: int, start_col: int, end_line: int, end_col: int
    ) -> str:
        if start_line == end_line:
            res = self.code[start_line - 1][max(0, start_col - 1) : end_col - 1]
        else:
            res = self.code[start_line - 1][max(0, start_col - 1) :]

        for line in range(start_line, end_line - 1):
            res += self.code[line]

        if start_line != end_line:
            res += self.code[end_line - 1][: end_col - 1]

        return res

    def __get_element_info(self, meta: Meta | Token) -> ElementInfo:
        return ElementInfo(
            meta.line,
            meta.column,
            meta.end_line,
            meta.end_column,
            self.__get_element_code(
                meta.line,
                meta.column,
                meta.end_line,
                meta.end_column,
            ),
        )
    
    def __parse_heredoc(self, tree: Tree) -> str:
        res = ""
        for arg in tree.children:
            res += arg.value
        return "\n".join(res.split("\n")[1:-1])

    @v_args(meta=True)
    def int_lit(self, meta: Meta, args: List) -> int:
        return Integer(int(args[0]), self.__get_element_info(meta))

    @v_args(meta=True)
    def expr_term(self, meta: Meta, args: List) -> Expr:
        if len(args) == 0:
            return Null(self.__get_element_info(meta))
        elif len(args) == 1:
            if isinstance(args[0], Tree) and args[0].data == 'heredoc_template':
                return String(
                    self.__parse_heredoc(args[0]),
                    self.__get_element_info(meta),
                )
            if isinstance(args[0], Expr):
                return args[0]
            if (args[0].type == "STRING_LIT"):
                return String(
                    args[0].value[1:-1],  # Remove quotes
                    self.__get_element_info(args[0]),
                )
            return args[0]
        return args

    def object_elem(self, args: List) -> Expr:
        self.object_elems[args[0]] = args[2]

    @v_args(meta=True)
    def object(self, meta: Meta, args: List) -> Any:
        res = Hash(self.object_elems, self.__get_element_info(meta))
        self.object_elems = {}
        return res
    
    @v_args(meta=True)
    def tuple(self, meta: Meta, args: List) -> Any:
        return Array(args, self.__get_element_info(meta))

    @v_args(meta=True)
    def block(self, meta: Meta, args: List) -> Any:
        print(args)
        if args[0] == GLITCHTransformer.ObjectType.RESOURCE:
            au = AtomicUnit(
                String(
                    args[2].value[1:-1],  # Remove quotes
                    self.__get_element_info(args[2]),
                ),
                args[1].value[1:-1],
            )
            au.attributes = self.attributes
            au.set_element_info(self.__get_element_info(meta))
            self.attributes = []
            return au

    def body(self, args: List) -> Any:
        return args

    @v_args(meta=True)
    def attribute(self, meta: Meta, args: List) -> Attribute:
        self.attributes.append(
            Attribute(args[0].value.value, args[2], self.__get_element_info(meta))
        )

    @v_args(meta=True)
    def identifier(self, meta: Meta, value: Any) -> Expr | ObjectType:
        if value[0] == "null":
            return Null(self.__get_element_info(meta))
        elif value[0] in ["true", "false"]:
            return Boolean(value[0] == "true", self.__get_element_info(meta))
        elif value[0] == "resource":
            return GLITCHTransformer.ObjectType.RESOURCE
        elif value[0] == "dynamic":
            return GLITCHTransformer.ObjectType.DYNAMIC
        return VariableReference(value[0], self.__get_element_info(meta))

    def start(self, args: List):
        return args[0]


class TerraformParser(p.Parser):
    def parse_file(self, path: str, type: UnitBlockType) -> UnitBlock:
        unit_block = UnitBlock(path, type)
        unit_block.path = path
        try:
            with open(path) as f:
                tree = hcl2.parse(f.read() + "\n")
                f.seek(0, 0)
                code = f.readlines()
                transformer = GLITCHTransformer(code)
                elements = transformer.transform(tree)
                for el in elements:
                    if isinstance(el, AtomicUnit):
                        unit_block.add_atomic_unit(el)
                for c in transformer.comments:
                    unit_block.add_comment(c)
        except:
            throw_exception(EXCEPTIONS["TERRAFORM_COULD_NOT_PARSE"], path)
        return unit_block

    def parse_module(self, path: str) -> Module:
        res: Module = Module(os.path.basename(os.path.normpath(path)), path)
        super().parse_file_structure(res.folder, path)

        files = [
            f.path for f in os.scandir(f"{path}") if f.is_file() and not f.is_symlink()
        ]
        for f in files:
            unit_block = self.parse_file(f, UnitBlockType.unknown)
            res.add_block(unit_block)

        return res

    def parse_folder(self, path: str) -> Project:
        res: Project = Project(os.path.basename(os.path.normpath(path)))
        res.add_module(self.parse_module(path))

        subfolders = [
            f.path for f in os.scandir(f"{path}") if f.is_dir() and not f.is_symlink()
        ]
        for d in subfolders:
            aux = self.parse_folder(d)
            res.blocks += aux.blocks
            res.modules += aux.modules

        return res
