import os
from hcl2.parser import hcl2
import glitch.parsers.parser as p

from glitch.exceptions import EXCEPTIONS, throw_exception
from glitch.repr.inter import *
from typing import Sequence, List, Dict, Any

from lark.tree import Meta
from lark.lexer import Token
from lark.visitors import Transformer, v_args, Discard


class GLITCHTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a dict.
    """

    class ObjectType(Enum):
        RESOURCE = 1
        ATTRIBUTE = 2

    def __init__(self, code: List[str]):
        self.code = code
        self.attributes = []
        super().__init__()

    def new_line_or_comment(self, args: List) -> List:
        return Discard

    def __get_element_code(
        self, start_line: int, start_col: int, end_line: int, end_col: int
    ) -> str:
        if start_line == end_line:
            res = self.code[start_line - 1][max(0, start_col - 1) : end_col - 1]
        else:
            res = self.code[start_line - 1][max(0, start_col - 1) :]

        for line in range(start_line, end_line - 1):
            res += self.code[line]

        if start_line != end_line:
            res += self.code[end_line - 1][: end_col - 1]

        return res

    def __get_element_info(self, meta: Meta | Token) -> ElementInfo:
        return ElementInfo(
            meta.line,
            meta.column,
            meta.end_line,
            meta.end_column,
            self.__get_element_code(
                meta.line,
                meta.column,
                meta.end_line,
                meta.end_column,
            ),
        )

    @v_args(meta=True)
    def int_lit(self, meta: Meta, args: List) -> int:
        print("HI")

    # @v_args(meta=True)
    # def string_lit(self, meta: Meta, args: List) -> str:
    #     return String(
    #         args[0],
    #         ElementInfo(
    #             meta.line,
    #             meta.column,
    #             meta.end_line,
    #             meta.end_column,
    #             GLITCHTransformer.__get_element_code(
    #                 meta.line,
    #                 meta.column,
    #                 meta.end_line,
    #                 meta.end_column,
    #             )
    #         )
    #     )

    @v_args(meta=True)
    def expr_term(self, meta: Meta, args: List) -> Expr:
        if len(args) == 0:
            return Null(self.__get_element_info(meta))
        elif len(args) == 1:
            return args[0]
        return args

    @v_args(meta=True)
    def block(self, meta: Meta, args: List) -> Any:
        if args[0] == GLITCHTransformer.ObjectType.RESOURCE:
            au = AtomicUnit(
                String(
                    args[2].value[1:-1],  # Remove quotes
                    self.__get_element_info(args[2]),
                ),
                args[1].value[1:-1],
            )
            au.attributes = self.attributes
            au.set_element_info(self.__get_element_info(meta))
            self.attributes = []
            return au

    def body(self, args: List) -> Any:
        return args

    @v_args(meta=True)
    def attribute(self, meta: Meta, args: List) -> Attribute:
        self.attributes.append(
            Attribute(args[0].value, args[1], self.__get_element_info(meta))
        )

    @v_args(meta=True)
    def identifier(self, meta: Meta, value: Any) -> Expr | ObjectType:
        if value[0] == "null":
            return Null(self.__get_element_info(meta))
        elif value[0] == "resource":
            return GLITCHTransformer.ObjectType.RESOURCE
        return VariableReference(value[0], self.__get_element_info(meta))

    def start(self, args: List):
        return args[0]


class TerraformParser(p.Parser):
    def parse_file(self, path: str, type: UnitBlockType) -> UnitBlock:
        unit_block = UnitBlock(path, type)
        unit_block.path = path
        try:
            with open(path) as f:
                tree = hcl2.parse(f.read() + "\n")
                f.seek(0, 0)
                code = f.readlines()
                elements = GLITCHTransformer(code).transform(tree)
                for el in elements:
                    if isinstance(el, AtomicUnit):
                        unit_block.add_atomic_unit(el)
        except:
            throw_exception(EXCEPTIONS["TERRAFORM_COULD_NOT_PARSE"], path)
        return unit_block

    def parse_module(self, path: str) -> Module:
        res: Module = Module(os.path.basename(os.path.normpath(path)), path)
        super().parse_file_structure(res.folder, path)

        files = [
            f.path for f in os.scandir(f"{path}") if f.is_file() and not f.is_symlink()
        ]
        for f in files:
            unit_block = self.parse_file(f, UnitBlockType.unknown)
            res.add_block(unit_block)

        return res

    def parse_folder(self, path: str) -> Project:
        res: Project = Project(os.path.basename(os.path.normpath(path)))
        res.add_module(self.parse_module(path))

        subfolders = [
            f.path for f in os.scandir(f"{path}") if f.is_dir() and not f.is_symlink()
        ]
        for d in subfolders:
            aux = self.parse_folder(d)
            res.blocks += aux.blocks
            res.modules += aux.modules

        return res
